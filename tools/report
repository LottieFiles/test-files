#!/usr/bin/env python3

import re
import sys
import json
import argparse
from pathlib import Path
from xml.etree import ElementTree
from PIL import Image, ImageChops
import cv2
import numpy
import sewar.full_ref

class Example:
    def __init__(self, name):
        self.name = name
        self.files = {}
        self.features = set()

    def append(self, file):
        self.files[file.stem] = file

    def mark_features(self, score, features):
        if len(self.features) == 0:
            self.features = {self.name}

        for feat in self.features:
            if feat in features:
                features[feat]["max"] += 1
                features[feat]["score"] += score
            else:
                features[feat] = {"max": 1, "score": score}


class ExampleFile:
    def __init__(self, path, data):
        self.path = path
        self.stem = path.stem
        self.data = data


def collect_files(root: Path, path: Path, out: dict, suffix:str):
    for file in (root / path).iterdir():
        if file.is_dir():
            collect_files(root, path / file.name, out, suffix)
        elif file.suffix == suffix:
            basename = re.sub("-[0-9]+$", "", file.stem)
            example_name = str(path / basename)
            if example_name not in out:
                out[example_name] = Example(example_name)

            if suffix == ".png":
                data = Image.open(file).convert("RGBA")
            else:
                data = None

            out[example_name].append(ExampleFile(file, data))
        elif file.name.endswith("-meta.json"):
            example_name = str(path / file.stem[:-5])
            if example_name not in out:
                out[example_name] = Example(example_name)

            with open(file) as f:
                out[example_name].features = set(json.load(f).get("features", []))


def collect_directory(path: Path, suffix:str = "png"):
    out = {}
    collect_files(path, Path(), out, "." + suffix)
    return out


def pil_to_cv(image: Image.Image):
    return cv2.cvtColor(numpy.array(image), cv2.COLOR_RGBA2BGRA)


def convert_img_to_hist(image):
    hist = cv2.calcHist(
        [image], [0, 1, 2], None, [256, 256, 256],
        [0, 256, 0, 256, 0, 256]
    )
    hist = cv2.normalize(hist, hist).flatten()
    return hist


def opencv_similarity(rendered: Image.Image, source: Image.Image):
    cv_source = pil_to_cv(source)
    cv_rendered = pil_to_cv(rendered)

    # orig_hist = convert_img_to_hist(cv_source)
    # rendered_hist = convert_img_to_hist(cv_rendered)
    # cv2.compareHist(orig_hist, rendered_hist, cv2.HISTCMP_CHISQR)

    return sewar.full_ref.uqi(cv_source, cv_rendered)


def compare_datum(test_item, reference_item, result, path_prefix):
    result["max"] += 1
    data = {
        "reference": path_prefix + str(reference_item.path),
        "ok": False,
        "score": 0,
    }
    result["items"].append(data)

    if test_item is None:
        data["source"] = None
        data["status"] = "missing-data"
        return 0

    data["source"] = path_prefix + str(test_item.path)
    test_img = test_item.data
    ref_img = reference_item.data

    if test_img.width != ref_img.width or test_img.height != ref_img.height:
        data["status"] = "size-mismatch"
        return 0

    data["status"] = "ok"
    # hist = ImageChops.difference(test_img, ref_img).histogram()
    # data["histogram"] = hist
    data["ok"] = True
    uqi = opencv_similarity(test_img, ref_img)
    data["uqi"] = uqi
    score = uqi ** 3
    if score > 0.99:
        score = 1
    data["score"] = score
    result["score"] += score
    return score


def compare_data(test_data, reference_data, path_prefix):
    keys = set(test_data.keys()) | set(reference_data.keys())

    features = {}
    results = {}

    for key in sorted(keys):
        test_item = test_data.get(key)

        if test_item is None:
            results[key] = {
                "status": "missing-data",
                "score": 0,
                "max": 0,
                "items": [],
            }

        reference_item = reference_data.get(key)
        if reference_item is None:
            results[key] = {
                "status": "missing-reference",
                "score": 0,
                "max": 0,
                "items": [],
            }

        result = {
            "status": "ok",
            "score": 0,
            "max": 0,
            "items": [],
        }
        results[key] = result

        for name, file in reference_item.files.items():
            score = compare_datum(test_item.files.get(name), file, result, path_prefix)
            reference_item.mark_features(score, features)

    return {
        "features": features,
        "tests": results,
    }


def render_html(report, path):
    html = ElementTree.Element("html")
    head = ElementTree.SubElement(html, "head")
    title = ElementTree.SubElement(head, "title")
    body = ElementTree.SubElement(html, "body")
    ElementTree.SubElement(body, "h1").text = "Features"
    table = ElementTree.SubElement(body, "table")
    tr = ElementTree.SubElement(table, "tr")
    ElementTree.SubElement(tr, "th").text = "Feature"
    ElementTree.SubElement(tr, "th").text = "Score"
    for fname, fdata in report["features"].items():
        tr = ElementTree.SubElement(table, "tr")
        ElementTree.SubElement(tr, "td").text = fname
        ElementTree.SubElement(tr, "td").text = "%g%%" % (
            fdata["score"] / fdata["max"] * 100
        )

    ElementTree.SubElement(body, "h1").text = "Tests"
    table = ElementTree.SubElement(body, "table")
    tr = ElementTree.SubElement(table, "tr")
    ElementTree.SubElement(tr, "th").text = "Name"
    ElementTree.SubElement(tr, "th").text = "File"
    ElementTree.SubElement(tr, "th").text = "Score"
    ElementTree.SubElement(tr, "th").text = "Reference"
    ElementTree.SubElement(tr, "th").text = "Render"

    for name, result in report["tests"].items():
        for item in result["items"]:
            tr = ElementTree.SubElement(table, "tr")
            ElementTree.SubElement(tr, "td").text = name
            ElementTree.SubElement(tr, "td").text = item["reference"].rsplit("/", 1)[-1]
            ElementTree.SubElement(tr, "td").text = "%g%%" % (item["score"] * 100)
            td = ElementTree.SubElement(tr, "td")
            if item["reference"]:
                ElementTree.SubElement(td, "img").attrib["src"] = "file://" + str(Path(item["reference"]).absolute())
            td = ElementTree.SubElement(tr, "td")
            if item["source"]:
                ElementTree.SubElement(td, "img").attrib["src"] = "file://" + str(Path(item["source"]).absolute())


    with open(path, "wb") as f:
        f.write(ElementTree.tostring(html, "utf8", "html"))

if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Generate a report based on rendered files"
    )
    parser.add_argument(
        "--reference",
        help="Root path for the reference data",
        type=Path,
        default=(Path(__file__).parent.parent / "data").relative_to(Path().absolute())
    )
    parser.add_argument(
        "path",
        help="Path to check against the reference",
        type=Path
    )
    parser.add_argument(
        "--output", "-o",
        help="Output file path",
        type=Path,
        default=None
    )
    parser.add_argument(
        "--prefix",
        help="Prefix for file names in the output",
        type=str,
        default=""
    )
    parser.add_argument(
        "--html",
        help="File path for the HTML report",
        type=Path,
        default=None
    )

    args = parser.parse_args()
    reference = collect_directory(args.reference)
    test = collect_directory(args.path)
    data = compare_data(test, reference, args.prefix)
    out = sys.stdout if args.output is None else open(args.output, "w")
    json.dump(data, out, indent=4)
    out.write("\n")

    if args.html:
        render_html(data, args.html)
