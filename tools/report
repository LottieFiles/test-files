#!/usr/bin/env python3

import re
import sys
import json
import argparse
from pathlib import Path
from xml.etree import ElementTree
from PIL import Image, ImageChops
import cv2
import numpy
import sewar.full_ref

class Example:
    def __init__(self, name):
        self.name = name
        self.files = {}
        self.features = set()

    def append(self, file):
        self.files[file.stem] = file

    def mark_features(self, score, features, index, count):
        if len(self.features) == 0:
            self.features = {self.name}

        for feat in self.features:
            if feat not in features:
                features[feat] = {"max": 1, "score": [0] * count}
            elif index == 0:
                features[feat]["max"] += 1

            features[feat]["score"][index] += score


class ExampleFile:
    def __init__(self, path, data):
        self.path = path
        self.stem = path.stem
        self.data = data


def collect_files(root: Path, path: Path, out: dict, suffix:str):
    for file in (root / path).iterdir():
        if file.is_dir():
            collect_files(root, path / file.name, out, suffix)
        elif file.name == "meta.json":
            continue
        elif "asset" in file.name:
            continue
        elif file.suffix == suffix:
            basename = re.sub("-[0-9]+$", "", file.stem)
            example_name = str(path / basename)
            if example_name not in out:
                out[example_name] = Example(example_name)

            if suffix == ".png":
                data = Image.open(file).convert("RGBA")
            else:
                data = None

            out[example_name].append(ExampleFile(file, data))
        elif file.name.endswith("-meta.json"):
            example_name = str(path / file.stem[:-5])
            if example_name not in out:
                out[example_name] = Example(example_name)

            with open(file) as f:
                features = set()
                for feat in json.load(f).get("features", []):
                    split = feat.split("/")
                    for i in range(len(split)):
                        features.add("/".join(split[0:i+1]))

            out[example_name].features = features


def collect_directory(path: Path, suffix:str = "png"):
    out = {}
    collect_files(path, Path(), out, "." + suffix)
    return out


def pil_to_cv(image: Image.Image):
    transp = numpy.array([0, 0, 0, 0])
    arr = numpy.array(image)
    for y in range(len(arr)):
        for x in range(len(arr[y])):
            if arr[y][x][3] == 0:
                arr[y][x] = transp
    return cv2.cvtColor(arr, cv2.COLOR_RGBA2BGRA)


def convert_img_to_hist(image):
    hist = cv2.calcHist(
        [image], [0, 1, 2], None, [256, 256, 256],
        [0, 256, 0, 256, 0, 256]
    )
    hist = cv2.normalize(hist, hist).flatten()
    return hist


def opencv_similarity(rendered: Image.Image, source: Image.Image):
    cv_source = pil_to_cv(source)
    cv_rendered = pil_to_cv(rendered)

    # orig_hist = convert_img_to_hist(cv_source)
    # rendered_hist = convert_img_to_hist(cv_rendered)
    # cv2.compareHist(orig_hist, rendered_hist, cv2.HISTCMP_CHISQR)

    return sewar.full_ref.uqi(cv_source, cv_rendered)


def compare_datum(test_item, reference_item, result, path_prefix):
    if test_item is None:
        result["status"] = "missing-data"
        return 0

    result["source"] = path_prefix + str(test_item.path)
    test_img = test_item.data
    ref_img = reference_item.data

    if test_img.width != ref_img.width or test_img.height != ref_img.height:
        result["status"] = "size-mismatch"
        return 0

    result["status"] = "ok"
    # hist = ImageChops.difference(test_img, ref_img).histogram()
    # result["histogram"] = hist
    result["ok"] = True
    uqi = opencv_similarity(test_img, ref_img)
    result["uqi"] = uqi
    score = uqi ** 3
    if score > 0.90:
        score = 1
    result["score"] = score
    return score


def compare_data(render_sets, reference_data, path_prefix):
    keys = set(reference_data.keys())

    for render_set in render_sets:
        skipped = set(render_set.meta.get("skipped", []))
        keys |= set(render_set.data.keys())
        keys -= skipped

    features = {}
    results = {}


    for index, render_set in enumerate(render_sets):
        for key in sorted(keys):
            test_item = render_set.data.get(key)

            reference_item = reference_data.get(key)
            if reference_item is None:
                continue

            for name, file in reference_item.files.items():
                results_key = str(file.path)

                if index == 0:
                    results[results_key] = {
                        "test": key,
                        "file": file.path.name,
                        "reference": path_prefix + str(file.path),
                        "score": 0,
                        "max": 0,
                        "results": [
                            {
                                "source": None,
                                "status": "unknown",
                                "ok": False,
                                "score": 0,
                                "uqi": 0,
                            }
                            for i in range(len(render_sets))],
                    }

                result = results[results_key]["results"][index]

                score = compare_datum(test_item.files.get(name) if test_item else None, file, result, path_prefix)

                results[results_key]["score"] += score
                results[results_key]["max"] += 1

                reference_item.mark_features(score, features, index, len(render_sets))

    return {
        "meta": [render_set.meta for render_set in render_sets],
        "features": features,
        "tests": sorted(results.values(), key=lambda r: (r["test"], r["file"])),
    }


def html_percent(value, parent, title):
    e = ElementTree.SubElement(parent, "div")
    e.attrib["class"] = "percent-parent"
    e.attrib["title"] = title
    ElementTree.SubElement(e, "span").text = "%.3g%%" % (value * 100)
    bar = ElementTree.SubElement(e, "span")
    bar.attrib["class"] = "percent-bar"
    ElementTree.SubElement(bar, "span").attrib["style"] = "width: %s%%" % (value * 100)


def render_html(report, path: Path):
    html = ElementTree.Element("html")
    head = ElementTree.SubElement(html, "head")
    ElementTree.SubElement(head, "style").text = """
    body {
        width: 100vw;
        max-width: 1024px;
        margin: 0 auto;
    }

    td:first-child {
        width: 100%;
    }

    td, th {
        border: 1px solid silver;
        padding: 5px;
        white-space: nowrap;
        /*height: inherit;*/
    }

    th {
        background: #eee;
    }

    table {
        border-collapse: collapse;
        width: 100%;
        height: 1px; /* ignored but needed for height:100% in td o_O */
    }

    table img {
        display: block;
        margin: 0 auto;
    }

    td.bad {
        background: #fcc;
    }
    td.meh {
        background: #eea;
    }

    .percent-parent {
        display: flex;
        flex-flow: column;
    }

    span.percent-bar {
        height: 5px;
        border: 1px solid silver;
        background: #c44;
    }

    .percent-bar > span {
        background: #4c4;
        display: block;
        height: 100%;
    }

    .score-set {
        display: flex;
        justify-content: space-around;
        border-top: 1px solid silver;
        margin: 0 -5px;
        padding: 0 5px;
    }

    .result-pic {
        display: flex;
        flex-flow: column;
        height: 100%;
    }
    """
    if len(report["meta"]) == 1:
        meta = report["meta"][0]
        column_titles = [report["meta"][0]["label"] or "Result"]
    else:
        formats = []
        commands = []
        column_titles = []

        def push(ls, item):
            if not ls or ls[-1] != item:
                ls.append(item)

        for rm in report["meta"]:
            push(formats, rm["format"])
            push(commands, rm["command"])
            column_titles.append(rm["label"])

        meta = {
            "title": report["meta"][0]["title"],
            "format": ", ".join(formats),
            "command": "\n".join(commands),
            "comment": "",
        }

    title = "%s %s report" % (meta["title"], meta["format"])
    ElementTree.SubElement(head, "title").text = title
    body = ElementTree.SubElement(html, "body")

    ElementTree.SubElement(body, "h1").text = title
    if meta["comment"]:
        p = ElementTree.SubElement(body, "p")
        p.text = ElementTree.SubElement(body, "p").text = meta["comment"]

    if meta["command"]:
        ElementTree.SubElement(body, "p").text = "Render command:"
        ElementTree.SubElement(ElementTree.SubElement(body, "pre"), "code").text = meta["command"]

    ElementTree.SubElement(body, "h2").text = "Features"
    table = ElementTree.SubElement(body, "table")
    tr = ElementTree.SubElement(table, "tr")
    ElementTree.SubElement(tr, "th").text = "Feature"
    for col in column_titles:
        ElementTree.SubElement(tr, "th").text = col

    for fname, fdata in sorted(report["features"].items()):
        tr = ElementTree.SubElement(table, "tr")
        ElementTree.SubElement(tr, "td").text = fname
        for score in fdata["score"]:
            html_percent(score / fdata["max"], ElementTree.SubElement(tr, "td"), "Score")

    ElementTree.SubElement(body, "h2").text = "Tests"

    button = ElementTree.SubElement(body, "button")
    button.text = "All"
    button.attrib["onclick"] = '''document.getElementById("table-tests").querySelectorAll("tr:not(.title)").forEach(tr => {
        tr.style.display = "table-row";
    });'''

    button = ElementTree.SubElement(body, "button")
    button.text = "Only Failures"
    button.attrib["onclick"] = '''document.getElementById("table-tests").querySelectorAll("tr:not(.title)").forEach(tr => {
        tr.style.display = tr.dataset.status == "ok" ? "none" : "table-row";
    });'''

    input = ElementTree.SubElement(body, "input")
    input.attrib["placeholder"] = "Filter"
    input.attrib["oninput"] = '''document.getElementById("table-tests").querySelectorAll("tr:not(.title)").forEach(tr => {
        tr.style.display = this.value != "" && tr.textContent.indexOf(this.value) == -1 ? "none" : "table-row";
    });'''


    table = ElementTree.SubElement(body, "table")
    table.attrib["id"] = "table-tests"
    tr = ElementTree.SubElement(table, "tr")
    tr.attrib["class"] = "title"
    ElementTree.SubElement(tr, "th").text = "Name"
    ElementTree.SubElement(tr, "th").text = "File"
    ElementTree.SubElement(tr, "th").text = "Score"
    ElementTree.SubElement(tr, "th").text = "Reference"
    for col in column_titles:
        ElementTree.SubElement(tr, "th").text = col

    def score_class(element, score):
        if score < 0.8:
            element.attrib["class"] = "bad"
        elif score < 1:
            element.attrib["class"] = "meh"
        else:
            element.attrib["class"] = "good"


    for item in report["tests"]:
        tr = ElementTree.SubElement(table, "tr")
        avg_score = item["score"] / item["max"]

        ElementTree.SubElement(tr, "td").text = item["test"]
        ElementTree.SubElement(tr, "td").text = item["file"]
        html_percent(avg_score, ElementTree.SubElement(tr, "td"), "Average Score")

        col = ElementTree.SubElement(ElementTree.SubElement(tr, "td"), "div")
        col.attrib["class"] = "result-pic"
        if item["reference"]:
            ElementTree.SubElement(col, "img").attrib["src"] = "file://" + str(Path(item["reference"]).absolute())

        ElementTree.SubElement(col, "div").attrib["class"] = "score-set"

        for result in item["results"]:
            td = ElementTree.SubElement(tr, "td")
            score_class(td, result["score"])

            tr.attrib["data-status"] = "fail" if result["score"] < 1 else "ok"

            col = ElementTree.SubElement(td, "div")
            col.attrib["class"] = "result-pic"

            if result["source"]:
                ElementTree.SubElement(col, "img").attrib["src"] = "file://" + str(Path(result["source"]).absolute())
            else:
                ElementTree.SubElement(col, "div")

            div = ElementTree.SubElement(col, "div")
            div.attrib["class"] = "score-set"
            html_percent(result["uqi"], div, "UQI")
            html_percent(result["score"], div, "Score")

    footer = ElementTree.SubElement(ElementTree.SubElement(body, "footer"), "p")
    footer.text = "Report generated from "
    link = ElementTree.SubElement(footer, "a")
    link.text = "Lottie test files"
    link.attrib["href"] = "https://github.com/LottieFiles/test-files"
    link.tail = "."

    with open(path, "wb") as f:
        f.write(ElementTree.tostring(html, "utf8", "html"))

    print("HTML report created at file://%s" % path.absolute())


class RenderSet:
    def __init__(self, path):
        self.data = collect_directory(path)
        meta_path = path / "meta.json"
        self.meta = {
            "title": "Lottie",
            "label": "",
            "comment": "",
            "command": "",
            "skipped": [],
            "format": "json",
        }
        if meta_path.exists:
            with open(meta_path) as f:
                self.meta.update(json.load(f))


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Generate a report based on rendered files"
    )
    parser.add_argument(
        "--reference",
        help="Root path for the reference data",
        type=Path,
        default=(Path(__file__).parent.parent / "data").relative_to(Path().absolute())
    )
    parser.add_argument(
        "path",
        help="Path of the render set to compare to the reference",
        nargs="+",
        type=Path
    )
    parser.add_argument(
        "--output", "-o",
        help="Output file path",
        type=Path,
        default=None
    )
    parser.add_argument(
        "--prefix",
        help="Prefix for file names in the output",
        type=str,
        default=""
    )
    parser.add_argument(
        "--html",
        help="File path for the HTML report",
        type=Path,
        default=None
    )

    args = parser.parse_args()
    reference = collect_directory(args.reference)
    render_sets = [RenderSet(path) for path in args.path]

    data = compare_data(render_sets, reference, args.prefix)
    out = sys.stdout if args.output is None else open(args.output, "w")
    json.dump(data, out, indent=4)
    out.write("\n")

    if args.html:
        render_html(data, args.html)
